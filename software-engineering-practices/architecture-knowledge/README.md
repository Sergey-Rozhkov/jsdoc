# Architecture knowledge

## ​Парадигмы программирования

[**Парадигма программирования**](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0\_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F) — это совокупность идей и понятий, определяющих стиль написания компьютерных программ (подход к программированию). Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером.

[**Объектно-ориентированное программирование**](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5\_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

* **Наследование** — свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.
* **Инкапсуляция** — свойство системы, которое позволяет объединять данные и код, манипулирующий этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования, скрывает реализацию.
* **Полиморфизм** — свойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
* **Абстрагирование** — означает выделение значимой информации и исключение из рассмотрения незначимой. В ООП рассматривают лишь абстракцию данных (нередко называя её просто «абстракцией»), подразумевая набор значимых характеристик объекта, доступный остальной программе.

[**Функциональное программирование**](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5\_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) — парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании).\
Противопоставляется парадигме императивного программирования, которая описывает процесс вычислений как последовательное изменение состояний (в значении, подобном таковому в теории автоматов). При необходимости, в функциональном программировании вся совокупность последовательных состояний вычислительного процесса представляется явным образом, например, как список.

**Чистая функция** — функция, которая:

1. является детерминированной, для одного и того же набора входных значений она возвращает одинаковый результат.
2. не обладает побочными эффектами.

**Побочный эффект (side effects)** — любые действия работающей программы, изменяющие среду выполнения (execution environment). Например, к побочным эффектам относятся:

* доступ (чтение или запись) к глобальным переменным;
* изменение (запись) объекта;
* изменение файла;
* изменение поведения инструкций процессора, обрабатывающих числа с плавающей точкой;
* вызов функции, выполняющей любое из перечисленных выше действий.

**Побочный эффект функции** — возможность в процессе выполнения своих вычислений:

* читать и модифицировать значения глобальных переменных
* осуществлять операции ввода-вывода
* реагировать на исключительные ситуации, вызывать их обработчики

Если вызвать функцию с побочным эффектом дважды с одним и тем же набором значений входных аргументов, может случиться так, что в качестве результата будут возвращены разные значения. Такие функции называются недетерминированными функциями с побочными эффектами.

[**Реактивное программирование**](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5\_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) — парадигма программирования, ориентированная на асинхронные потоки данных и распространение изменений. Это означает, что должна существовать возможность легко выражать статические и динамические потоки данных, а также то, что нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных. [https://habr.com/post/279715/](https://habr.com/post/279715/)

[**Процедурное программирование**](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%BD%D0%BE%D0%B5\_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) — программирование на императивном языке, при котором последовательно выполняемые операторы можно собрать в подпрограммы, то есть более крупные целостные единицы кода, с помощью механизмов самого языка.

## [SOLID](https://ru.wikipedia.org/wiki/SOLID\_\(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5\_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5\))

SOLID - аббревиатура пяти основных принципов дизайна классов в объектно-ориентированном проектировании — **S**ingle responsibility, **O**pen-closed, **L**iskov substitution, **I**nterface segregation и **D**ependency inversion.

* **`Принцип единственности ответственности`**`(The Single Responsibility Principle)` - на каждый объект должна быть возложена одна единственная обязанность
* **`Принцип открытости/закрытости`**`(The Open Closed Principle)`- сущности должны быть открыты для расширения, но закрыты для модификации
* **`Принцип замещения Лисков`**`(The Liskov Substitution Principle)` - Объекты в программе могут быть заменены их наследниками без изменения свойств программы
* **`Принцип разделения интерфейса`**`(The Interface Segregation Principle)` - Много специализированных интерфейсов лучше, чем один универсальный
* **`Принцип инверсии зависимости`**`(The Dependency Inversion Principle)` - Зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций

Шпаргалка по SOLID-принципам - [https://habr.com/post/208442/](https://habr.com/post/208442/)

## DRY

**Don’t repeat yourself**, DRY (рус. не повторяйся) — это принцип разработки программного обеспечения, нацеленный на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования. Принцип DRY формулируется как: «Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы». Он был сформулирован Энди Хантом (англ.) и Дэйвом Томасом (англ.) в их книге The Pragmatic Programmer(англ.). Они применяли этот принцип к «схемам баз данных, планам тестирования, сборкам программного обеспечения, даже к документации». Когда принцип DRY применяется успешно, изменение единственного элемента системы не требует внесения изменений в другие, логически не связанные элементы. Те элементы, которые логически связаны, изменяются предсказуемо и единообразно. Помимо использования методов и функций в коде, Томас и Хант считают необходимым использование генераторов кода, автоматических систем компиляции.

## [Design pattern](https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD\_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

Шаблон проектирования или паттерн (design pattern) в разработке программного обеспечения —  это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.

Обычно шаблон не является законченным образцом, который может быть прямо преобразован в код; это лишь пример решения задачи, который можно использовать в различных ситуациях. Объектно-ориентированные шаблоны показывают отношения и взаимодействия между классами или объектами, без определения того, какие конечные классы или объекты приложения будут использоваться.

* **Fundamental** - Общие
  * `Делегирование` -  объект внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.
  * `Неизменяемый интерфейс` -  создание объекта, состояние которого не может быть изменено после создания.
  * `Интерфейс` - общий метод для структурирования компьютерных программ для того, чтобы их было проще понять.
  * `Контейнер свойств` - позволяет добавлять дополнительные свойства для класса в контейнер (внутри класса), вместо расширения класса новыми свойствами.
* **Creational** - Порождающие (предоставляют механизмы инициализации, позволяя создавать объекты удобным способом)
  * `Абстрактная фабрика` -   Необходимо создавать объекты классов не имеющих иерархической связи, но логически связанных между собой. Абстрактный класс-фабрика определяет общий интерфейс таких фабрик. Его подклассы обладают конкретной реализацией методов по созданию разных объектов.
  * `Фабрика` -  Для того, чтобы система оставалась независимой от различных типов объектов, паттерн Factory Method использует механизм полиморфизма - классы всех конечных типов наследуют от одного абстрактного базового класса, предназначенного для полиморфного использования. В этом базовом классе определяется единый интерфейс, через который пользователь будет оперировать объектами конечных типов.
  * `Multiton` - список именованных созданных экземпляров классов, которые в итоге используются как Singleton-ы, но в заданном заранее N-ном количестве.
  * `Singleton` -   Необходимо создание объекта класса таким образом, чтобы гарантировать невозможность инициализации другого объекта того же класса. Обычно сам класс контролирует наличие единственного экземпляра и он же предоставляет при необходимости к нему доступ.
  * `Prototype` - используется, если создание объекта класса требует много времени или является достаточно сложным. Тогда вместо создания нескольких объектов класса используется копирование существующего объекта.
  * `Lazy initialization` -  объект, инициализируемый только во время первого обращения к нему.
* **Structural** - Структурные (определяют отношения между классами и объектами, позволяя им работать совместно)
  * `Adapter` - применяется при необходимости использовать вместе несвязанные классы. Поведение адаптируемого класса при этом изменяется на необходимое.
  * `Decorator` - Класс, расширяющий функциональность другого класса без использования наследования.
  * `Facade` - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.
  * `Единая точка входа` - Обеспечивает унифицированный интерфейс для интерфейсов в подсистеме. Front Controller определяет высокоуровневый интерфейс, упрощающий использование подсистемы.
  * `Proxy` - Объект, который является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.
* **Behavioral** - Поведенчиское ( используются для того, чтобы упростить взаимодействие между сущностями)
  * `Интерпретатор`
  * `Iterator` -  позволяет последовательно обойти все элементы составного объекта, не зная деталей внутреннего представления данных.
  * `Observer` - Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом и автоматически обновляются.
  * `Visitor` -  позволяет создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться.
  * `Состояние` -  это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния.
* **Architectural** - Архитектурные
  * [Model-View-Controller](https://ru.wikipedia.org/wiki/Model-View-Controller) (MVC)
  * [Model-View-Presenter](https://ru.wikipedia.org/wiki/Model-View-Presenter) (MVP)
  * [Model-View-View Model](https://ru.wikipedia.org/wiki/Model-View-View\_Model) (MVVM)

**Антипаттерн** (англ. anti-pattern) — это распространённый подход к решению класса часто встречающихся проблем, являющийся неэффективным, рискованным или непродуктивным. В отличие от шаблона проектирования, рассмотрение антипаттерна включает в себя как неправильное решение проблемы с его признаками и последствиями, так и выход из ситуации.

## MVC & MVVM & MVP

### **Model-View-Presenter**

![](https://habrastorage.org/getpro/habr/post\_images/f1b/cbf/d44/f1bcbfd44fc367c0e07e00d957ac188a.png)

&#x20;Данный подход позволяет создавать абстракцию представления. Для этого необходимо выделить интерфейс представления с определенным набором свойств и методов. Презентер, в свою очередь, получает ссылку на реализацию интерфейса, подписывается на события представления и по запросу изменяет модель.\


#### **Признаки презентера:**

* Двухсторонняя коммуникация с представлением;
* Представление взаимодействует напрямую с презентером, путем вызова соответствующих функций или событий экземпляра презентера;
* Презентер взаимодействует с View путем использования специального интерфейса, реализованного представлением;
* Один экземпляр презентера связан с одним отображением.

### **Model-View-View Model**&#x20;

![](../../.gitbook/assets/3a38f65895eec8816ccacb3388de200a.png)

Данный подход позволяет связывать элементы представления со свойствами и событиями View-модели. Можно утверждать, что каждый слой этого паттерна не знает о существовании другого слоя.

#### **Признаки View-модели:**

* Двухсторонняя коммуникация с представлением;
* View-модель — это абстракция представления. Обычно означает, что свойства представления совпадают со свойствами View-модели / модели
* View-модель не имеет ссылки на интерфейс представления (IView). Изменение состояния View-модели автоматически изменяет представление и наоборот, поскольку используется механизм связывания данных (Bindings)
* Один экземпляр View-модели связан с одним отображением.

### **Model-View-Controller**

\
![](https://habrastorage.org/getpro/habr/post\_images/01c/c4f/3f2/01cc4f3f2646eaea356bc50dccce40d6.png)

Основная идея этого паттерна в том, что и контроллер и представление зависят от модели, но модель никак не зависит от этих двух компонент.

#### **Признаки контроллера:**

* Контроллер определяет, какие представление должно быть отображено в данный момент;
* События представления могут повлиять только на контроллер.контроллер может повлиять на модель и определить другое представление.
* Возможно несколько представлений только для одного контроллера;

### **Общие правила выбора паттерна**

#### **MVVM**

* Используется в ситуации, когда возможно связывание данных без необходимости ввода специальных интерфейсов представления (т.е. отсутствует необходимость реализовывать IView);
* Частым примером является технология WPF.

#### **MVP**

* Используется в ситуации, когда невозможно связывание данных (нельзя использовать Binding);
* Частым примером может быть использование Windows Forms.

#### **MVC**

* Используется в ситуации, когда связь между представление и другими частями приложения невозможна (и Вы не можете использовать MVVM или MVP);
* Частым примером использования может служить ASP.NET MVC.

Источник: [Паттерны для новичков: MVC vs MVP vs MVVM](https://habr.com/post/215605/)\
Дополнительные материалы: [Martin Fowler — GUI Architectures. Часть 1](https://habr.com/post/50830/)
