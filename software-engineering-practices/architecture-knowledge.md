# Architecture knowledge

## ​Парадигмы программирования

[**Парадигма программирования**](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F) — это совокупность идей и понятий, определяющих стиль написания компьютерных программ \(подход к программированию\). Это способ концептуализации, определяющий организацию вычислений и структурирование работы, выполняемой компьютером.

[**Объектно-ориентированное программирование**](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

* **Наследование** — свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.
* **Инкапсуляция** — свойство системы, которое позволяет объединять данные и код, манипулирующий этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования, скрывает реализацию.
* **Полиморфизм** — свойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
* **Абстрагирование** — означает выделение значимой информации и исключение из рассмотрения незначимой. В ООП рассматривают лишь абстракцию данных \(нередко называя её просто «абстракцией»\), подразумевая набор значимых характеристик объекта, доступный остальной программе.

[**Функциональное программирование**](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) — парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних \(в отличие от функций как подпрограмм в процедурном программировании\).  
Противопоставляется парадигме императивного программирования, которая описывает процесс вычислений как последовательное изменение состояний \(в значении, подобном таковому в теории автоматов\). При необходимости, в функциональном программировании вся совокупность последовательных состояний вычислительного процесса представляется явным образом, например, как список.

**Чистая функция** — функция, которая:

1. является детерминированной, для одного и того же набора входных значений она возвращает одинаковый результат.
2. не обладает побочными эффектами.

**Побочный эффект \(side effects\)** — любые действия работающей программы, изменяющие среду выполнения \(execution environment\). Например, к побочным эффектам относятся:

* доступ \(чтение или запись\) к глобальным переменным;
* изменение \(запись\) объекта;
* изменение файла;
* изменение поведения инструкций процессора, обрабатывающих числа с плавающей точкой;
* вызов функции, выполняющей любое из перечисленных выше действий.

**Побочный эффект функции** — возможность в процессе выполнения своих вычислений:

* читать и модифицировать значения глобальных переменных
* осуществлять операции ввода-вывода
* реагировать на исключительные ситуации, вызывать их обработчики

Если вызвать функцию с побочным эффектом дважды с одним и тем же набором значений входных аргументов, может случиться так, что в качестве результата будут возвращены разные значения. Такие функции называются недетерминированными функциями с побочными эффектами.

[**Реактивное программирование**](https://ru.wikipedia.org/wiki/Реактивное_программирование) — парадигма программирования, ориентированная на асинхронные потоки данных и распространение изменений. Это означает, что должна существовать возможность легко выражать статические и динамические потоки данных, а также то, что нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных. [https://habr.com/post/279715/](https://habr.com/post/279715/)

[**Процедурное программирование**](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) — программирование на императивном языке, при котором последовательно выполняемые операторы можно собрать в подпрограммы, то есть более крупные целостные единицы кода, с помощью механизмов самого языка.

## [SOLID](https://ru.wikipedia.org/wiki/SOLID_%28%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29)

SOLID - аббревиатура пяти основных принципов дизайна классов в объектно-ориентированном проектировании — **S**ingle responsibility, **O**pen-closed, **L**iskov substitution, **I**nterface segregation и **D**ependency inversion.

* **`Принцип единственности ответственности`**`(The Single Responsibility Principle)` - на каждый объект должна быть возложена одна единственная обязанность
* **`Принцип открытости/закрытости`**`(The Open Closed Principle)`- сущности должны быть открыты для расширения, но закрыты для модификации
* **`Принцип замещения Лисков`**`(The Liskov Substitution Principle)` - Объекты в программе могут быть заменены их наследниками без изменения свойств программы
* **`Принцип разделения интерфейса`**`(The Interface Segregation Principle)` - Много специализированных интерфейсов лучше, чем один универсальный
* **`Принцип инверсии зависимости`**`(The Dependency Inversion Principle)` - Зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций

Шпаргалка по SOLID-принципам - [https://habr.com/post/208442/](https://habr.com/post/208442/)

## DRY

**Don’t repeat yourself**, DRY \(рус. не повторяйся\) — это принцип разработки программного обеспечения, нацеленный на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования. Принцип DRY формулируется как: «Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы»\[1\]. Он был сформулирован Энди Хантом \(англ.\) и Дэйвом Томасом \(англ.\) в их книге The Pragmatic Programmer\(англ.\). Они применяли этот принцип к «схемам баз данных, планам тестирования, сборкам программного обеспечения, даже к документации»\[2\]. Когда принцип DRY применяется успешно, изменение единственного элемента системы не требует внесения изменений в другие, логически не связанные элементы. Те элементы, которые логически связаны, изменяются предсказуемо и единообразно. Помимо использования методов и функций в коде, Томас и Хант считают необходимым использование генераторов кода, автоматических систем компиляции.

## [Design pattern](https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

Шаблон проектирования или паттерн \(design pattern\) в разработке программного обеспечения —  это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.

Обычно шаблон не является законченным образцом, который может быть прямо преобразован в код; это лишь пример решения задачи, который можно использовать в различных ситуациях. Объектно-ориентированные шаблоны показывают отношения и взаимодействия между классами или объектами, без определения того, какие конечные классы или объекты приложения будут использоваться.

* **Fundamental** - Общие
  * `Делегирование` -  объект внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.
  * `Неизменяемый интерфейс` -  создание объекта, состояние которого не может быть изменено после создания.
  * `Интерфейс` - общий метод для структурирования компьютерных программ для того, чтобы их было проще понять.
  * `Контейнер свойств` - позволяет добавлять дополнительные свойства для класса в контейнер \(внутри класса\), вместо расширения класса новыми свойствами.
* **Creational** - Порождающие \(предоставляют механизмы инициализации, позволяя создавать объекты удобным способом\)
  * `Абстрактная фабрика` -   Необходимо создавать объекты классов не имеющих иерархической связи, но логически связанных между собой. Абстрактный класс-фабрика определяет общий интерфейс таких фабрик. Его подклассы обладают конкретной реализацией методов по созданию разных объектов.
  * `Фабрика` -  Для того, чтобы система оставалась независимой от различных типов объектов, паттерн Factory Method использует механизм полиморфизма - классы всех конечных типов наследуют от одного абстрактного базового класса, предназначенного для полиморфного использования. В этом базовом классе определяется единый интерфейс, через который пользователь будет оперировать объектами конечных типов.
  * `Multiton` - список именованных созданных экземпляров классов, которые в итоге используются как Singleton-ы, но в заданном заранее N-ном количестве.
  * `Singleton` -   Необходимо создание объекта класса таким образом, чтобы гарантировать невозможность инициализации другого объекта того же класса. Обычно сам класс контролирует наличие единственного экземпляра и он же предоставляет при необходимости к нему доступ.
  * `Prototype` - используется, если создание объекта класса требует много времени или является достаточно сложным. Тогда вместо создания нескольких объектов класса используется копирование существующего объекта.
  * `Lazy initialization` -  объект, инициализируемый только во время первого обращения к нему.
* **Structural** - Структурные \(определяют отношения между классами и объектами, позволяя им работать совместно\)
  * `Adapter` - применяется при необходимости использовать вместе несвязанные классы. Поведение адаптируемого класса при этом изменяется на необходимое.
  * `Decorator` - Класс, расширяющий функциональность другого класса без использования наследования.
  * `Facade` - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.
  * `Единая точка входа` - Обеспечивает унифицированный интерфейс для интерфейсов в подсистеме. Front Controller определяет высокоуровневый интерфейс, упрощающий использование подсистемы.
  * `Proxy` - Объект, который является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.
* **Behavioral** - Поведенчиское \( используются для того, чтобы упростить взаимодействие между сущностями\)
  * `Интерпретатор`
  * `Iterator` -  позволяет последовательно обойти все элементы составного объекта, не зная деталей внутреннего представления данных.
  * `Observer` - Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом и автоматически обновляются.
  * `Visitor` -  позволяет создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться.
  * `Состояние` -  это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния.
* **Architectural** - Архитектурные
  * [Model-View-Controller](https://ru.wikipedia.org/wiki/Model-View-Controller) \(MVC\)
  * [Model-View-Presenter](https://ru.wikipedia.org/wiki/Model-View-Presenter) \(MVP\)
  * [Model-View-View Model](https://ru.wikipedia.org/wiki/Model-View-View_Model) \(MVVM\)

**Антипаттерн** \(англ. anti-pattern\) — это распространённый подход к решению класса часто встречающихся проблем, являющийся неэффективным, рискованным или непродуктивным. В отличие от шаблона проектирования, рассмотрение антипаттерна включает в себя как неправильное решение проблемы с его признаками и последствиями, так и выход из ситуации.

## MVC & MVVM & MVP

### ToDo write me please

