---
description: HyperText Markup Language & Cascading Style Sheets
---

# HTML & CSS

* HTML
  * HTML5 APIs
  * DOM/BOM
  * Semantic
* CSS
  * Selectors (Cascade/Specificity)
  * Поток документа
  * Pseudo-classes / Pseudo-elements
  * Media queries
  * Layouts (float/inline-block/flex/grid)
  * Animations
* Tools
  * LESS / SCSS / PostCSS
  * CSS Frameworks

## HTML

* [**HTML**](https://ru.wikipedia.org/wiki/HTML) (HyperText Markup Language — «язык гипертекстовой разметки») — стандартизированный язык разметки документов во Всемирной паутине. Большинство веб-страниц содержат описание разметки на языке **HTML** (или XHTML).&#x20;
* [**XHTML**](https://ru.wikipedia.org/wiki/XHTML) является более строгим вариантом HTML, он следует синтаксису XML и является приложением языка XML в области разметки гипертекста.

{% code title="Структура HTML-документа" %}
```markup
<!DOCTYPE html>
<html>
   <head>
      <meta charset="utf-8" />
      <title>HTML Document</title>
   </head>
   <body>
      <p>
         <b>
            Этот текст будет полужирным, <i>а этот — ещё и курсивным</i>.
         </b>
      </p>
   </body>
</html>
```
{% endcode %}

### Версии HTML

* Официальной спецификации HTML 1.0 не существует. До 1995 года существовало множество неофициальных стандартов HTML. Чтобы стандартная версия отличалась от них, ей сразу присвоили второй номер.
* HTML 2.0 — опубликован IETF как RFC 1866 в статусе Proposed Standard (24 ноября 1995 года);
* HTML 3.0 — 28 марта 1995 года — IETF Internet Draft (до 28 сентября 1995 года);
* HTML 3.2 — 14 января 1997 года;
* HTML 4.0 — 18 декабря 1997 года;
* HTML 4.01 — 24 декабря 1999 года;
* HTML 5 — 28 октября 2014 года;
* HTML 5.1 начал разрабатываться 17 декабря 2012 года. **Рекомендован к применению с 1 ноября 2016 года.**
* HTML 5.2 был представлен 14 декабря 2017 года.

### HTML5

Термин имеет два определения:

* Новая версия _языка_ HTML, с новыми элементами, атрибутами и новым поведением.
* Набор технологий, позволяющий создавать разнообразные сайты и Web-приложения.

{% embed url="https://html5test.com/" %}

{% embed url="https://developer.mozilla.org/ru/docs/HTML/HTML5" %}

{% embed url="https://www.html5accessibility.com/" %}

#### New HTML5 Elements

* New **semantic elements** like `<header>`, `<footer>`, `<article>`, and `<section>`.
* New **attributes of form elements** like number, date, time, calendar, and range.
* New **graphic elements**: `<svg>` and `<canvas>`.
* New **multimedia elements**: `<audio>` and `<video>`.

#### New HTML5 API's (Application Programming Interfaces)

* HTML Geolocation
* HTML [Drag and Drop](https://www.html5rocks.com/en/tutorials/dnd/basics/)
* HTML Local Storage
* HTML Application Cache
* HTML Web Workers
* HTML SSE

![](<.gitbook/assets/image (18).png>)

![Семантические теги](<.gitbook/assets/image (22).png>)

### Общие вопросы

![](<.gitbook/assets/image (25).png>)

* **DOCTYPE** — это определение типа документа (Document Type Definition (DTD)), правила, в соответствии с которыми осуществляется проверка конкретного документа (веб-страницы) XML или (X)HTML. Благодаря этой записи, браузер определяет, какая в данном документе используется версия DTD. А нужен он для того, чтобы браузеры правильно отображали разметку документа. Если не указать DOCTYPE, то браузер будет добавлять "что то от себя", причём каждые браузеры будут добавлять свою "что то от себя". В результате, ни о какой кроссбраузерности не может идти и речи.
* **DOM** (Document Object Model — «объектная модель документа») — это независящий от платформы и языка программный интерфейс, позволяющий программам и скриптам получить доступ к содержимому HTML-, XHTML- и XML-документов, а также изменять содержимое, структуру и оформление таких документов.
* **BOM** (Browser Object Model — «объектная модель браузера») — это часть JavaScript, которая позволяет скрипту взаимодействовать с программой просмотра веб-страниц. BOM представляет объекты, через свойства и методы которых можно управлять внешним видом и поведением обозревателя.
* Чем отличается `div` от `span`?&#x20;
  * **div** - блочный контейнер, **span** - строчный контейнер. Контейнеры - это то, во что может быть вложено что-нибудь еще. div используется для разметки блоков, а span - для текста. div формирует блок из того, что в нем с новой строки и после него элемент идет с новой строки (если не поменять поведение с помощью CSS), а span не переносит и "обтягивает".
* Объясните разницу между `<script>`, `<script async>` и `<script defer>`
  * атрибут `defer` сохраняет относительную последовательность скриптов, а `async` – нет. Кроме того, `defer` всегда ждёт, пока весь HTML-документ будет готов, а `async` – нет.
* **Ссылки**. Как задать адрес документа, на который следует перейти?&#x20;
  * \<a href="https://jsehelper.blogspot.com/example/example.html">**Абсолютная ссылка<**/a>
  * \<a href="../../example/example.html">**Относительная ссылка**\</a>
  * \<a href="mailto:testmail@mail.com">E-mail me\</a>
  * \<a href="tel:+375291234567">Call me\</a>
* Тэги `<ol></ol>`, `<ul></ul>` и `<li></li>`
  * Теги \<ol>\<ol> устанавливает **нумерованный список**. Каждый элемент списка должен начинаться и заканчиваться тегами \<li>\<li> Если к тегу \<ol> применяется таблица стилей, то элементы \<li> наследуют эти свойства. Тег \<ul> устанавливает **ненумерованный (маркированный) список**.
* Тэги `<dl>`,`<dt>`,`<dd>`
  * Теги \<dl>,\<dt>,\<dd> предназначенны для создания списка определений. Каждый такой список начинается с контейнера \<dl>, куда входит тег \<dt> создающий термин и тег \<dd> задающий определение этого термина. Закрывающий тег \</dd> не обязателен, поскольку следующий тег сообщает о завершении предыдущего элемента. Тем не менее, хорошим стилем является закрывать все теги.
* Что пишут в теге HEAD?
  * `<title>` - очень важный тег, особенно с точки зрения SEO
  * `<meta>` **-** мета теги, в основном, нужны для трёх вещей: прописать кодировку, description (описание) и keywords (ключевые слова).
  * `<style>` - Также внутри тегов head прописывается путь к таблице стилей, так связывается веб-страница и таблица стилей, или CSS пишется прямо на странице, внутри тегов **style**.
  * `<script>` - Внутри тега head подключаются всевозможные скрипты, прописываются теги **script** с указанием типа языка и внутри них или пишется код скрипта, или к тегу **script** прописывается атрибут **src**, в котором указывается путь к скрипту.
* В каком регистре лучше писать HTML-код?&#x20;
  * Раньше считалось, что это безразлично. Но с приходом XHTML на этот вопрос появился однозначный ответ - все теги, атрибуты и предопределенные значения пишем в нижнем регистре.
* Обязательно ли писать alt в `<img>`?
  * позволяет поисковому роботу «увидеть» изображение и проиндексировать его. По сути, краткое описание того, что изображено на картинке
* Что такое **entities**?
  * **Символ-мнемоника** (англ. **entity**) — это конструкция SGML, которая ссылается на символ из набора символов текстового файла. То есть это комбинации знака & и буквенного или цифрового кода после нее, предназначенные для замещения символов, которые не могут встречаться в "чистом" виде в HTML-тексте, например, символа "<".\
    В HTML предопределено большое количество спецсимволов. Чтобы вставить определённый символ в разметку, нужно вставить определённую ссылку-мнемонику в HTML-структуру.
* Нужно ли в HTML закрывать одиночные тэги?
  * Согласно спецификации в html некоторые теги нужно обязательно закрывать, некоторые необязательно, а некоторые запрещено. Примеры:
    * Обязательно нужно закрывать `div`, `span`, `script`, `table` и `footer`;
    * Такие теги, как `option`, `li`, `tr`, `body` можно закрывать, а можно и нет. С точки зрения качества кода, конечно, лучше всегда закрывать теги, но стандарт разрешает не делать этого;
    * А вот некоторые теги, такие как `input`, `br`, `img` и `hr` закрывать запрещено. Если написать `<input></input>` или `<img></img>` — то это будет невалидный html. Такие теги нужно оставлять незакрытыми.
* Типы верстки:
  * Табличная
  * Блочная
  * Адаптивная
* Чем полезны `data-*` атрибуты?
  * Синтаксис в HTML прост — любой атрибут, чьё имя начинается с `data-`, является `data-*` атрибутом.
  * Чтение `data-`атрибутов в **JavaScript** осуществляется также просто. Для этого можно использовать метод getAttribute() с параметром, равным полному имени атрибута. Но есть и более простой способ, используя объект dataset.
  * Заметим, что `data-`атрибуты являются обычными **HTML**-атрибутами, к которым можно получить доступ в **CSS**. Например:
    * Чтобы показать родительские данные о статье можно использовать генерируемый контент и CSS функцию `attr`.&#x20;
    * Также можно использовать селекторы атрибутов в CSS для изменения стилей в соответствии с данным.
    * `Data-`атрибуты также могут использоваться для хранения информации, которая постоянно изменяется, например, счёт в игре.&#x20;
    * Используя CSS селекторы и возможности JavaScript можно создавать некоторые изящные эффекты, без необходимости писать свои функции отображения.
* Объясните разницу между `cookies`, `sessionStorage` и `localStorage`&#x20;
  * [В чем разница между localStorage, sessionStorage, сеансом и куки?](http://qaru.site/questions/19679/what-is-the-difference-between-localstorage-sessionstorage-session-and-cookies)
* Что такое прогрессивный рендеринг?
  * [Ленивая загрузка](https://en.wikipedia.org/wiki/Lazy\_loading) изображений, где (как правило) некоторые javascript загружают изображение, когда оно попадает в окно просмотра браузеров, вместо загрузки всех изображений при загрузке страницы.
  * [Приоритет видимого содержимого](https://developers.google.com/speed/docs/insights/PrioritizeVisibleContent) (или выше рендеринга сложения), где вы включаете только минимальные css/content/скрипты, необходимые для количества страницы, которая будет отображаться в чтобы браузер отображался как можно быстрее, вы можете использовать отложенный javascript (domready/load) для загрузки других ресурсов и контента.

## CSS

[**CSS**](https://ru.wikipedia.org/wiki/CSS) (Cascading Style Sheets — каскадные таблицы стилей) — формальный язык описания внешнего вида документа, написанного с использованием языка разметки.

Преимущественно используется как средство описания, оформления внешнего вида веб-страниц, написанных с помощью языков разметки HTML и XHTML, но может также применяться к любым XML-документам, например, к SVG или XUL.

{% code title="Пример таблицы стилей" %}
```css
p {
    background-color: black;
}

div.warning p {
    background-color: red;
}

div#caution p {
    background-color: yellow;
}

body#home .container p {
    background-color: white;
}

.note {
    background-color: green;
}

a:hover {
    text-decoration: none;
}

#home p {
    background-color: blue;
}

[type="button"] {
    background-color: green;
}

html body.app div:first-child p .title {
    display: none;
}

* {
    padding: 10px;
    margin: 10px;
    background-color: #CCCCCC;
}
```
{% endcode %}

### Версии CSS

* CSS v1 - Рекомендация W3C, принята 17 декабря 1996 года, откорректирована 11 января 1999 года. Среди возможностей, предоставляемых этой рекомендацией:
  * Параметры шрифтов. Возможности по заданию гарнитуры и размера шрифта, а также его стиля — обычного, курсивного или полужирного.
  * Цвета. Спецификация позволяет определять цвета текста, фона, рамок и других элементов страницы.
  * Атрибуты текста. Возможность задавать межсимвольный интервал, расстояние между словами и высоту строки (то есть межстрочные отступы)
  * Выравнивание для текста, изображений, таблиц и других элементов.
  * Свойства блоков, такие как высота, ширина, внутренние (`padding`) и внешние (`margin`) отступы и рамки. Также в спецификацию входили ограниченные средства по позиционированию элементов, такие как `float` и `clear`.
* CSS v2 - Рекомендация W3C, принята 12 мая 1998 года. Основана на CSS1 с сохранением обратной совместимости за несколькими исключениями. Добавление к функциональности:
  * Блочная вёрстка. Появились относительное, абсолютное и фиксированное позиционирование. Позволяет управлять размещением элементов по странице без табличной вёрстки.
  * Типы носителей. Позволяет устанавливать разные стили для разных носителей (например монитор, принтер, КПК).
  * Звуковые таблицы стилей. Определяет голос, громкость и т. д. для звуковых носителей (например для слепых посетителей сайта).
  * Страничные носители. Позволяет, например, установить разные стили для элементов на чётных и нечётных страницах при печати.
  * Расширенный механизм селекторов.
  * Указатели.
  * Генерируемое содержимое. Позволяет добавлять содержимое, которого нет в исходном документе, до или после нужного элемента.
  * В настоящее время W3C больше не поддерживает CSS2 и рекомендует использовать CSS2.1
* CSS v2.1 - Рекомендация W3C, принята 7 июня 2011 года.
  * CSS2.1 основана на CSS2. Кроме исправления ошибок, в новой ревизии изменены некоторые части спецификации, а некоторые и вовсе удалены. Удаленные части могут быть в будущем добавлены в CSS3.
* CSS v3
  * активно разрабатываемая спецификация CSS. Представляет собой формальный язык, реализованный с помощью языка разметки. Самая масштабная редакция по сравнению с CSS1, CSS2 и CSS2.1.
  * Главной особенностью CSS3 является возможность создавать **анимированные элементы** без использования JS, поддержка линейных и радиальных **градиентов**, **теней**, **сглаживания**, **закругления углов** блоков, **трансформация** (анимация), введение **переменных**.
* CSS v4 - Разрабатывается W3C с 29 сентября 2011 года.

### Общие вопросы

![Calculating CSS Specificity Value](<.gitbook/assets/image (16).png>)

![](<.gitbook/assets/image (48).png>)

* **Специфичность селектора**
  * это условные четыре позиции important `x, x, x, x` и `x, x, x, x,` которые заполняются нулями и единицами в соответствии с содержимым селектора. Каждая из позиций имеет своё содержимое:
    * Инлайн стили
    * Идентификаторы
    * Классы, атрибуты и псевдоклассы
    * Теги и псевдоэлементы
  * ```diff
    style=""       1,0,0,0
    #id            0,1,0,0
    .class         0,0,1,0
    [attr=value]   0,0,1,0
    LI             0,0,0,1
    *              0,0,0,0
    ```
  * [https://jonassebastianohlsson.com/specificity-graph/](https://jonassebastianohlsson.com/specificity-graph/)
  * Что если селекторы одинаковые ?
* **Поток документа**
  * В HTML формирование элементов на странице происходит слева на право и сверху вниз, согласно схеме документа. Слой, размещенный в самом верху кода, отобразится раньше слоя, который расположен в коде ниже.  Такая логика позволяет легко прогнозировать результат вывода элементов и управлять им. Порядок вывода объектов на странице и называется «потоком». При этом существует несколько возможностей «вырвать» элемент из потока и придать ему почти мифические свойства. Раз он не существует в потоке, то в коде его можно описать где угодно, а также выводить в заданное место окна.
* Как работают **флоаты**?
  * Свойство `float` превращает элемент в плавающий, при этом он прижимается к левому или правому краю родителя, а текст его обходит с других сторон.
* Как работает **позиционирование**?
  * Свойство `position` задает позиционирование элемента относительно исходного положения или родителя.
  * `absolute` - указывает, что элемент абсолютно позиционирован, **относительно ближайшего позиционированного родителя**, при этом другие элементы отображаются на веб-странице словно абсолютно позиционированного элемента и нет. Положение элемента задается свойствами left, top, right и bottom, также на положение влияет значение свойства `position` родительского элемента. Так, если у родителя значение position установлено как `static` или родителя нет, то отсчет координат ведется от края окна браузера. Если у родителя значение **position** задано как `fixed`, `relative` или `absolute`, то отсчет координат ведется от края родительского элемента.
  * `fixed` - значение близко к absolute, но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы. Браузер Firefox вообще не отображает полосы прокрутки, если положение элемента задано фиксированным, и оно не помещается целиком в окно браузера. В браузере Opera хотя и показываются полосы прокрутки, но они никак не влияют на позицию элемента.
  * `relative` - Положение элемента устанавливается **относительно его исходного места**. Добавление свойств left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения.
  * `static` - Элементы отображаются как обычно. Использование свойств left, top, right и bottom не приводит к каким-либо результатам.
  * `inherit` - Наследует значение родителя.
  * `sticky` - [Position: sticky](https://developer.mozilla.org/en-US/docs/Web/CSS/position#Sticky\_positioning)
* Как работают инлайн-блоки?
* Как работает _`z-index`_? Понятие «stacking context».
  * Контекст наложения (stacking context) это концепция трехмерного разположения HTML элементов вдоль оси Z , по отношению к пользователю, находящемуся перед экраном.  HTML элементы занимают это место по порядку, основанному на атрибутах элемента.
* Как подключаем стили к странице?
* Для чего необходим файл reset.css на сайте?
  *   ```css
      html, body, div, span, p, h1, h2, h3, h4, h5, h6, … {
          margin: 0;
          padding: 0;
          border: 0 none;
          outline: 0;
          font-size: 100%;
          vertical-align: baseline;
          background: transparent;
          text-decoration: none;
      }
      ```


* `margin` vs `padding`
* Что такое CSS спрайты? Как они реализуются на странице или сайте?
* Как оптимизировать страницу для печати?
* **CSS Framework** (также **Web design framework**)
  * это заранее подготовленная CSS-библиотека, созданная для упрощения работы верстальщика, быстроты разработки и исключения максимально возможного числа ошибок вёрстки (проблемы совместимости различных версий браузеров и т. д.). Так же как и библиотеки скриптовых языков программирования, CSS-фреймворки, обычно имеющие вид внешнего .css-файла, «подключаются» к проекту (добавляются в заголовок веб-страницы), позволяя неискушённому в тонкостях вёрстки программисту или дизайнеру правильно создать html-макет.
* Расширения CSS
  * [SASS](https://ru.wikipedia.org/wiki/Sass)
  * [LESS](https://ru.wikipedia.org/wiki/LESS\_\(%D1%8F%D0%B7%D1%8B%D0%BA\_%D1%81%D1%82%D0%B8%D0%BB%D0%B5%D0%B9\))

### Flexbox

Ссылка на визуальную шпаргалку по свойствам:

{% embed url="https://codepen.io/enxaneta/full/adLPwv" %}
Flexbox playground
{% endembed %}

Модуль _Flexbox_ (flexible box — «гибкий блок», на данный момент W3C Candidate Recommendation) ставит задачу предложить более эффективный способ вёрстки, выравнивания и распределения свободного места между элементами в контейнере, даже когда их размер неизвестен и/или динамический.

Главная задумка flex-вёрстки в наделении контейнера способностью изменять ширину/высоту (и порядок) своих элементов для наилучшего заполнения пространства (в большинстве случаев — для поддержки всех видов дисплеев и размеров экранов). Flex-контейнер растягивает элементы для заполнения свободного места или сжимает их, чтобы предотвратить выход за границы.

&#x20;Т.к. flexbox — это целый модуль, а не просто единичное свойство, он объединяет в себе множество свойств. Некоторые из них должны применяться к контейнеру (родительскому элементу, так называемому _flex-контейнеру_), в то время как другие свойства применяются к дочерним элементам, или _flex-элементам_.

![Основные оси на Flexbox.](.gitbook/assets/flexbox.png)

#### Свойства flexbox:

*   display: flex | inline-flex

    Применяется к: родительскому элементу flex-контейнера. Определяет flex-контейнер (инлайновый или блочный в зависимости от выбранного значения), подключает flex-контекст для всех его непосредственных потомков.
*   flex-direction

    Применяется к: родительскому элементу flex-контейнера. Устанавливает главную ось main-axis, определяя тем самым направление для flex-элементов, размещаемых в контейнере.
*   flex-wrap

    Применяется к: родительскому элементу flex-контейнера. Определяет, будет ли контейнер однострочным или многострочным, а также направление поперечной оси, определяющей направление, в котором будут располагаться новые строки.
*   flex-flow

    Применяется к: родительскому элементу flex-контейнера. Это сокращение для свойств flex-direction и flex-wrap, вместе определяющих главную и поперечную оси. По умолчанию принимает значение row nowrap
*   justify-content

    Применяется к: родительскому элементу flex-контейнера. Определяет выравнивание относительно главной оси. Помогает распределить оставшееся свободное место в случае, когда элементы строки не «тянутся», либо тянутся, но уже достигли своего максимального размера. Также позволяет в некотором роде управлять выравниванием элементов при выходе за границы строки.
*   align-items

    Применяется к: родительскому элементу flex-контейнера. Определяет поведение по умолчанию для того, как flex-элементы располагаются относительно поперечной оси на текущей строке. Считайте это версией justify-content для поперечной оси (перпендикулярной к основной).
*   align-content

    Применяется к: родительскому элементу flex-контейнера. Выравнивает строки flex-контейнера при наличии свободного места на поперечной оси аналогично тому, как это делает justify-content на главной оси.
*   order

    Применяется к: дочернему элементу / flex-элементу. По умолчанию flex-элементы располагаются в исходном порядке. Тем не менее, свойство order может управлять порядком их расположения в контейнере.
*   flex-grow

    Применяется к: дочернему элементу / flex-элементу. Определяет для flex-элемента возможность «вырастать» при необходимости. Принимает безразмерное значение, служащее в качестве пропорции. Оно определяет, какую долю свободного места внутри контейнера элемент может занять. Если у всех элементов свойство flex-grow задано как 1, то каждый потомок получит внутри контейнера одинаковый размер. Если вы задали одному из потомков значение 2, то он заберёт в два раза больше места, чем другие.
*   flex-shrink

    Применяется к: дочернему элементу / flex-элементу. Определяет для flex-элемента возможность сжиматься при необходимости.
*   flex-basis

    Применяется к: дочернему элементу / flex-элементу. Определяет размер по умолчанию для элемента перед распределением пространства в контейнере.
*   align-self

    Применяется к: дочернему элементу / flex-элементу. Позволяет переопределить выравнивание, заданное по умолчанию или в align-items, для отдельных flex-элементов.

Пример:

```css
.wrapper {
  display: flex;
  flex-flow: row wrap;
}

/* Задаём всем элементам ширину в 100% */
.header, .main, .nav, .aside, .footer {
  flex: 1 100%;
}
```

### Links

{% embed url="http://flexboxfroggy.com/" %}

{% embed url="https://cssgridgarden.com/#ru" %}



